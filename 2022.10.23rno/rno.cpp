/* 1 задание
    1) Конец области видимости
    - скопированный в функцию объект
    - созданный в функции временный объект
    2) Конец программы
    3) Присвоение с замещением
    Class Object {
        ...
    };

    Object a;
    Object b;
    a = b;
    4) Явный вызов деструктора
    ~Object(); или delete a;

    2 задание
    а) 
    - В конструктор копирования надо передавать const foo& A,
    потому что если передать foo A, при передаче в конструктор
    копирования вызовется конструктор копирования. Соответственно
    получится бесконечная рекурсия.
    - data = new int[size*2];
    - for(int i = 0; i/2 < size; ++i) непонятно, что за таинственное n
    и лучше писать ++i, хотя в данной ситуации это не играет особого
    значения.
    б)
    6 раз: первый раз, когда передадим (А, 11)
           второй вернем (А, 2)
           третий предадим (A, 2)
           четвертый вернем (A, 0)
           пятый передадим (А, 0)
           шестой вернем А

    3 задание
    Деструкторы вызываются в обратном порядке: от наследников к базовому классу.
    Поэтому так делать не надо:
    Class A {
    private:
        int* data;
        int size;
    public:
        A(int n) {
            size = n;
            data = new int[size*2];
        }
        ~A() {
            delete[] data;
        }
    };
    Class B : A {
    public:
        B(int n) {
            size = n;
            data = new int[size*5];
        }
        ~B() {
            delete[] data;         //тут data будет пытаться удалиться дважды, 
        }                          //один раз тут, потом вызовется деструктор
    };                             //базового класса. Будет ошибка.
    Так что в классе B можно не прописывать деструктор, потому что хорошо сработает 
    деструктор по умолчанию, после него вызовется деструктор базового класса и 
    спокойно удалит data.

    4 задание
    template <typename T, int size>
    class Array {
    private:
        T array[size]{};
    public:
        T& operator[](int index) {
            return array[index];
        }
     };

    template <int size>
    class Array<T*> { 
    private:
        T *array[size]{};
    public:
        T& operator[](int index) {
            return &array[index];
        }
    };

    5 задание
    1) существует ли а?
    2) можно ли приравнивать число к а?
    3) можно ли сравнивать а с числом?
    4) можно ли прибавлять к а 1?
    5) существует ли б?
    6) можно ли прибавлять к b 1?
    7) можно ли складывать а к b?
    8) можно ли сравнивать а+b и с?
    9) существует ли с?
    10) можно ли возвращать b?
    11) можно ли применять к с +=а?

    И того 11
*/

